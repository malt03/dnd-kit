{"version":3,"file":"sortable.cjs.production.min.js","sources":["../src/utilities/arrayMove.ts","../src/utilities/getSortedRects.ts","../src/utilities/isValidIndex.ts","../src/strategies/horizontalListSorting.ts","../src/strategies/rectSorting.ts","../src/strategies/verticalListSorting.ts","../src/components/SortableContext.tsx","../src/hooks/defaults.ts","../src/sensors/keyboard/sortableKeyboardCoordinates.ts","../src/utilities/arraySwap.ts","../src/strategies/rectSwapping.ts","../src/hooks/useSortable.ts","../src/hooks/utilities/useDerivedTransform.ts"],"sourcesContent":["/**\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\n */\nexport function arrayMove<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n  newArray.splice(\n    to < 0 ? newArray.length + to : to,\n    0,\n    newArray.splice(from, 1)[0]\n  );\n\n  return newArray;\n}\n","import type {\n  ClientRect,\n  UniqueIdentifier,\n  UseDndContextReturnValue,\n} from '@dnd-kit/core';\n\nexport function getSortedRects(\n  items: UniqueIdentifier[],\n  rects: UseDndContextReturnValue['droppableRects']\n) {\n  return items.reduce<ClientRect[]>((accumulator, id, index) => {\n    const rect = rects.get(id);\n\n    if (rect) {\n      accumulator[index] = rect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n","export function isValidIndex(index: number | null): index is number {\n  return index !== null && index >= 0;\n}\n","import type {ClientRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const horizontalListSortingStrategy: SortingStrategy = ({\n  rects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const activeNodeRect = rects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = rects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x:\n        activeIndex < overIndex\n          ? newIndexRect.left +\n            newIndexRect.width -\n            (activeNodeRect.left + activeNodeRect.width)\n          : newIndexRect.left - activeNodeRect.left,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(rects: ClientRect[], index: number, activeIndex: number) {\n  const currentRect: ClientRect | undefined = rects[index];\n  const previousRect: ClientRect | undefined = rects[index - 1];\n  const nextRect: ClientRect | undefined = rects[index + 1];\n\n  if (!currentRect || (!previousRect && !nextRect)) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.left - (previousRect.left + previousRect.width)\n      : nextRect.left - (currentRect.left + currentRect.width);\n  }\n\n  return nextRect\n    ? nextRect.left - (currentRect.left + currentRect.width)\n    : currentRect.left - (previousRect.left + previousRect.width);\n}\n","import {arrayMove} from '../utilities';\nimport type {SortingStrategy} from '../types';\n\nexport const rectSortingStrategy: SortingStrategy = ({\n  rects,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const newRects = arrayMove(rects, overIndex, activeIndex);\n\n  const oldRect = rects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {ClientRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const verticalListSortingStrategy: SortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  rects,\n  overIndex,\n}) => {\n  const activeNodeRect = rects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = rects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y:\n        activeIndex < overIndex\n          ? overIndexRect.top +\n            overIndexRect.height -\n            (activeNodeRect.top + activeNodeRect.height)\n          : overIndexRect.top - activeNodeRect.top,\n      ...defaultScale,\n    };\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  clientRects: ClientRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect: ClientRect | undefined = clientRects[index];\n  const previousRect: ClientRect | undefined = clientRects[index - 1];\n  const nextRect: ClientRect | undefined = clientRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.top - (previousRect.top + previousRect.height)\n      : nextRect\n      ? nextRect.top - (currentRect.top + currentRect.height)\n      : 0;\n  }\n\n  return nextRect\n    ? nextRect.top - (currentRect.top + currentRect.height)\n    : previousRect\n    ? currentRect.top - (previousRect.top + previousRect.height)\n    : 0;\n}\n","import React, {useEffect, useMemo, useRef} from 'react';\nimport {useDndContext, ClientRect, UniqueIdentifier} from '@dnd-kit/core';\nimport {useIsomorphicLayoutEffect, useUniqueId} from '@dnd-kit/utilities';\n\nimport type {SortingStrategy} from '../types';\nimport {getSortedRects} from '../utilities';\nimport {rectSortingStrategy} from '../strategies';\n\nexport interface Props {\n  children: React.ReactNode;\n  items: (UniqueIdentifier | {id: UniqueIdentifier})[];\n  strategy?: SortingStrategy;\n  id?: string;\n}\n\nconst ID_PREFIX = 'Sortable';\n\ninterface ContextDescriptor {\n  activeIndex: number;\n  containerId: string;\n  disableTransforms: boolean;\n  items: UniqueIdentifier[];\n  overIndex: number;\n  useDragOverlay: boolean;\n  sortedRects: ClientRect[];\n  strategy: SortingStrategy;\n}\n\nexport const Context = React.createContext<ContextDescriptor>({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n});\n\nexport function SortableContext({\n  children,\n  id,\n  items: userDefinedItems,\n  strategy = rectSortingStrategy,\n}: Props) {\n  const {\n    active,\n    dragOverlay,\n    droppableRects,\n    over,\n    measureDroppableContainers,\n    measuringScheduled,\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(dragOverlay.rect !== null);\n  const items = useMemo(\n    () =>\n      userDefinedItems.map((item) =>\n        typeof item === 'string' ? item : item.id\n      ),\n    [userDefinedItems]\n  );\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms =\n    (overIndex !== -1 && activeIndex === -1) || itemsHaveChanged;\n\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && !measuringScheduled) {\n      measureDroppableContainers(items);\n    }\n  }, [itemsHaveChanged, items, measureDroppableContainers, measuringScheduled]);\n\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n\n  const contextValue = useMemo(\n    (): ContextDescriptor => ({\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      useDragOverlay,\n      sortedRects: getSortedRects(items, droppableRects),\n      strategy,\n    }),\n    [\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      droppableRects,\n      useDragOverlay,\n      strategy,\n    ]\n  );\n\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>;\n}\n\nfunction isEqual(arr1: string[], arr2: string[]) {\n  if (arr1 === arr2) return true;\n  if (arr1.length !== arr2.length) return false;\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n","import {CSS} from '@dnd-kit/utilities';\n\nimport {arrayMove} from '../utilities';\n\nimport type {\n  AnimateLayoutChanges,\n  NewIndexGetter,\n  SortableTransition,\n} from './types';\n\nexport const defaultNewIndexGetter: NewIndexGetter = ({\n  id,\n  items,\n  activeIndex,\n  overIndex,\n}) => arrayMove(items, activeIndex, overIndex).indexOf(id);\n\nexport const defaultAnimateLayoutChanges: AnimateLayoutChanges = ({\n  containerId,\n  isSorting,\n  wasDragging,\n  index,\n  items,\n  newIndex,\n  previousItems,\n  previousContainerId,\n  transition,\n}) => {\n  if (!transition || !wasDragging) {\n    return false;\n  }\n\n  if (previousItems !== items && index === newIndex) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index && containerId === previousContainerId;\n};\n\nexport const defaultTransition: SortableTransition = {\n  duration: 200,\n  easing: 'ease',\n};\n\nexport const transitionProperty = 'transform';\n\nexport const disabledTransition = CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear',\n});\n\nexport const defaultAttributes = {\n  roleDescription: 'sortable',\n};\n","import {\n  closestCorners,\n  getScrollableAncestors,\n  getFirstCollision,\n  KeyboardCode,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n} from '@dnd-kit/core';\n\nconst directions: string[] = [\n  KeyboardCode.Down,\n  KeyboardCode.Right,\n  KeyboardCode.Up,\n  KeyboardCode.Left,\n];\n\nexport const sortableKeyboardCoordinates: KeyboardCoordinateGetter = (\n  event,\n  {\n    context: {\n      active,\n      collisionRect,\n      droppableRects,\n      droppableContainers,\n      over,\n      scrollableAncestors,\n    },\n  }\n) => {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!active || !collisionRect) {\n      return;\n    }\n\n    const filteredContainers: DroppableContainer[] = [];\n\n    droppableContainers.getEnabled().forEach((entry) => {\n      if (!entry || entry?.disabled) {\n        return;\n      }\n\n      const rect = entry?.rect.current;\n\n      if (!rect) {\n        return;\n      }\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (collisionRect.top < rect.top) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (collisionRect.top > rect.top) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (collisionRect.left > rect.left) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (collisionRect.left < rect.left) {\n            filteredContainers.push(entry);\n          }\n          break;\n      }\n    });\n\n    const collisions = closestCorners({\n      active,\n      collisionRect: collisionRect,\n      droppableRects,\n      droppableContainers: filteredContainers,\n      pointerCoordinates: null,\n    });\n    let closestId = getFirstCollision(collisions, 'id');\n\n    if (closestId === over?.id && collisions.length > 1) {\n      closestId = collisions[1].id;\n    }\n\n    if (closestId != null) {\n      const newDroppable = droppableContainers.get(closestId);\n      const newNode = newDroppable?.node.current;\n      const newRect = newDroppable?.rect.current;\n\n      if (newNode && newRect) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some(\n          (element, index) => scrollableAncestors[index] !== element\n        );\n        const offset = hasDifferentScrollAncestors\n          ? {\n              x: 0,\n              y: 0,\n            }\n          : {\n              x: collisionRect.width - newRect.width,\n              y: collisionRect.height - newRect.height,\n            };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y,\n        };\n\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n","/**\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\n */\nexport function arraySwap<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n\n  newArray[from] = array[to];\n  newArray[to] = array[from];\n\n  return newArray;\n}\n","import type {SortingStrategy} from '../types';\n\nexport const rectSwappingStrategy: SortingStrategy = ({\n  activeIndex,\n  index,\n  rects,\n  overIndex,\n}) => {\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = rects[index];\n    newRect = rects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = rects[index];\n    newRect = rects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import {useContext, useEffect, useMemo, useRef} from 'react';\nimport {\n  useDraggable,\n  useDroppable,\n  UseDraggableArguments,\n  UseDroppableArguments,\n} from '@dnd-kit/core';\nimport {CSS, isKeyboardEvent, useCombinedRefs} from '@dnd-kit/utilities';\n\nimport {Context} from '../components';\nimport type {SortingStrategy} from '../types';\nimport {isValidIndex} from '../utilities';\nimport {\n  defaultAnimateLayoutChanges,\n  defaultAttributes,\n  defaultNewIndexGetter,\n  defaultTransition,\n  disabledTransition,\n  transitionProperty,\n} from './defaults';\nimport type {\n  AnimateLayoutChanges,\n  NewIndexGetter,\n  SortableTransition,\n} from './types';\nimport {useDerivedTransform} from './utilities';\n\nexport interface Arguments\n  extends UseDraggableArguments,\n    Pick<UseDroppableArguments, 'resizeObserverConfig'> {\n  animateLayoutChanges?: AnimateLayoutChanges;\n  getNewIndex?: NewIndexGetter;\n  strategy?: SortingStrategy;\n  transition?: SortableTransition | null;\n}\n\nexport function useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled,\n  data: customData,\n  getNewIndex = defaultNewIndexGetter,\n  id,\n  strategy: localStrategy,\n  resizeObserverConfig,\n  transition = defaultTransition,\n}: Arguments) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n  } = useContext(Context);\n  const index = items.indexOf(id);\n  const data = useMemo(\n    () => ({sortable: {containerId, index, items}, ...customData}),\n    [containerId, customData, index, items]\n  );\n  const itemsAfterCurrentSortable = useMemo(\n    () => items.slice(items.indexOf(id)),\n    [items, id]\n  );\n  const {rect, node, isOver, setNodeRef: setDroppableNodeRef} = useDroppable({\n    id,\n    data,\n    resizeObserverConfig: {\n      updateMeasurementsFor: itemsAfterCurrentSortable,\n      ...resizeObserverConfig,\n    },\n  });\n  const {\n    active,\n    activatorEvent,\n    activeNodeRect,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform,\n  } = useDraggable({\n    id,\n    data,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes,\n    },\n    disabled,\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem =\n    isSorting &&\n    !disableTransforms &&\n    isValidIndex(activeIndex) &&\n    isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement =\n    shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy ?? globalStrategy;\n  const finalTransform = displaceItem\n    ? dragSourceDisplacement ??\n      strategy({\n        rects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index,\n      })\n    : null;\n  const newIndex =\n    isValidIndex(activeIndex) && isValidIndex(overIndex)\n      ? getNewIndex({id, items, activeIndex, overIndex})\n      : index;\n  const activeId = active?.id;\n  const previous = useRef({\n    activeId,\n    items,\n    newIndex,\n    containerId,\n  });\n  const itemsHaveChanged = items !== previous.current.items;\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    containerId,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: previous.current.newIndex,\n    previousItems: previous.current.items,\n    previousContainerId: previous.current.containerId,\n    transition,\n    wasDragging: previous.current.activeId != null,\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect,\n  });\n\n  useEffect(() => {\n    if (isSorting && previous.current.newIndex !== newIndex) {\n      previous.current.newIndex = newIndex;\n    }\n\n    if (containerId !== previous.current.containerId) {\n      previous.current.containerId = containerId;\n    }\n\n    if (items !== previous.current.items) {\n      previous.current.items = items;\n    }\n\n    if (activeId !== previous.current.activeId) {\n      previous.current.activeId = activeId;\n    }\n  }, [activeId, isSorting, newIndex, containerId, items]);\n\n  return {\n    active,\n    activeIndex,\n    attributes,\n    rect,\n    index,\n    newIndex,\n    items,\n    isOver,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform ?? finalTransform,\n    transition: getTransition(),\n  };\n\n  function getTransition() {\n    if (\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      derivedTransform ||\n      // Or to prevent items jumping to back to their \"new\" position when items change\n      (itemsHaveChanged && previous.current.newIndex === index)\n    ) {\n      return disabledTransition;\n    }\n\n    if (\n      (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent)) ||\n      !transition\n    ) {\n      return undefined;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty,\n      });\n    }\n\n    return undefined;\n  }\n}\n","import {useEffect, useRef, useState} from 'react';\nimport {getClientRect, ClientRect} from '@dnd-kit/core';\nimport {Transform, useIsomorphicLayoutEffect} from '@dnd-kit/utilities';\n\ninterface Arguments {\n  rect: React.MutableRefObject<ClientRect | null>;\n  disabled: boolean;\n  index: number;\n  node: React.MutableRefObject<HTMLElement | null>;\n}\n\n/*\n * When the index of an item changes while sorting,\n * we need to temporarily disable the transforms\n */\nexport function useDerivedTransform({disabled, index, node, rect}: Arguments) {\n  const [derivedTransform, setDerivedtransform] = useState<Transform | null>(\n    null\n  );\n  const previousIndex = useRef(index);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!disabled && index !== previousIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getClientRect(node.current, {\n          ignoreTransform: true,\n        });\n\n        const delta = {\n          x: initial.left - current.left,\n          y: initial.top - current.top,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height,\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== previousIndex.current) {\n      previousIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n\n  return derivedTransform;\n}\n"],"names":["arrayMove","array","from","to","newArray","slice","splice","length","getSortedRects","items","rects","reduce","accumulator","id","index","rect","get","Array","isValidIndex","defaultScale","scaleX","scaleY","rectSortingStrategy","activeIndex","overIndex","newRects","oldRect","newRect","x","left","y","top","width","height","Context","React","createContext","containerId","disableTransforms","useDragOverlay","sortedRects","strategy","defaultNewIndexGetter","indexOf","defaultAnimateLayoutChanges","isSorting","wasDragging","newIndex","previousItems","previousContainerId","transition","defaultTransition","duration","easing","disabledTransition","CSS","Transition","toString","property","defaultAttributes","roleDescription","directions","KeyboardCode","Down","Right","Up","Left","children","userDefinedItems","active","dragOverlay","droppableRects","over","measureDroppableContainers","measuringScheduled","useDndContext","useUniqueId","Boolean","useMemo","map","item","previousItemsRef","useRef","itemsHaveChanged","arr1","arr2","i","isEqual","current","useIsomorphicLayoutEffect","useEffect","contextValue","Provider","value","activeNodeRect","fallbackActiveRect","itemGap","currentRect","previousRect","nextRect","getItemGap","newIndexRect","event","context","collisionRect","droppableContainers","scrollableAncestors","includes","code","preventDefault","filteredContainers","getEnabled","forEach","entry","disabled","push","collisions","closestCorners","pointerCoordinates","closestId","getFirstCollision","newDroppable","newNode","node","offset","getScrollableAncestors","some","element","animateLayoutChanges","attributes","userDefinedAttributes","data","customData","getNewIndex","localStrategy","resizeObserverConfig","globalStrategy","useContext","sortable","itemsAfterCurrentSortable","isOver","setNodeRef","setDroppableNodeRef","useDroppable","updateMeasurementsFor","activatorEvent","setDraggableNodeRef","listeners","isDragging","transform","useDraggable","useCombinedRefs","displaceItem","shouldDisplaceDragSource","dragSourceDisplacement","finalTransform","activeId","previous","shouldAnimateLayoutChanges","derivedTransform","setDerivedtransform","useState","previousIndex","initial","getClientRect","ignoreTransform","delta","requestAnimationFrame","useDerivedTransform","isKeyboardEvent","overIndexRect","clientRects"],"mappings":"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"}